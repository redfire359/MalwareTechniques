/*

Compiled with mingw (sudo apt install gcc-mingw-w64)

x86_64-w64-mingw32-gcc injector_interactive.c -o injector_interactive.exe

*/


#include <windows.h>
#include <stdio.h>
#define WIN32_LEAN_AND_MEAN

int main(int argc, char* argv[]){

    char* DLL_Name;
    char dll_full_path[MAX_PATH];
    int PID;

    // Verify command line arguments
    if(argc == 3){
        PID = strtol(argv[1], NULL, 10);
        DLL_Name = argv[2];
    }
    else{
        printf("Usage: injector_interactive.exe <PID> <DLL>\n");
        printf("\tPID - Process ID of the process you want to inject.\n");
        printf("\tDLL - DLL that you'd like to inject into the process.\n");
        return -1;
    }

    // Verify PID is valid
    if(PID <= 0){
        printf("Invalid PID number\n");
        return -1;
    }
        printf("Process ID: %i\n", PID);

    // Get full path of DLL
    DWORD dll_pathname = GetFullPathNameA(DLL_Name, MAX_PATH, dll_full_path, NULL);
        if(dll_pathname == 0){
            printf("Error getting full path of DLL\n");
            return -1;
        }
        printf("DLL Path: %i\n", dll_pathname);

    // Attempt to get a handle on the target process
    HANDLE target_process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
        if(target_process_handle == INVALID_HANDLE_VALUE){
            printf("Error acquiring process handle, double check your PID...\n");
            return -1;
        }
        printf("Handle result: %i\n", target_process_handle);

    // Now that we have a handle, we can allocate memory within the process to fit our DLL into 
    LPVOID path_to_address = VirtualAllocEx(target_process_handle, NULL, sizeof(dll_full_path), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if(path_to_address == NULL){
            printf("Error allocating memory in the target process\n");
            return -1;
        }
        printf("Memory location: 0x%x\n", path_to_address);

    // Memorys been allocated, lets write the DLL
    DWORD proc_write_result = WriteProcessMemory(target_process_handle, path_to_address, dll_full_path, strlen(dll_full_path) + 1, NULL ); 
        if(proc_write_result == 0){
            printf("Error writing DLL to process\n");
            return -1;
        }
        printf("Writing DLL to memory location in process: %i\n");

    // Using LoadLibraryA to load DLL
 	PTHREAD_START_ROUTINE thread_routine_address = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryA");
    HANDLE load_library_handle = reateRemoteThread(target_process_handle, NULL, 0, thread_routine_address, path_to_address, 0, NULL);
    if(load_library_handle == INVALID_HANDLE_VALUE){
            printf("Error acquiring LoadLibraryA handle\n");
            return -1;
        }
        printf("DLL Successfully injected!");

    CloseHandle(target_process_handle);

    return 0 ;
}